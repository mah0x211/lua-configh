--
-- Copyright (C) 2023 Masatoshi Fukunaga
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-- THE SOFTWARE.
--
local assert = assert
local concat = table.concat
local format = string.format
local gsub = string.gsub
local open = io.open
local date = os.date
local remove = os.remove
local executor = require('configh.executor')

--- @class configh
--- @field macros string[]
--- @field exec configh.executor
local Configh = {}

--- new create a new configh object
--- @param cc string?
--- @return configh
function Configh:init(cc)
    self.macros = {
        '',
    }
    self.exec = executor(cc)

    return self
end

--- flush flush the generated definitions to the file
--- @param pathname string
--- @return boolean ok
--- @return string? err
function Configh:flush(pathname)
    assert(type(pathname) == 'string', 'pathname must be string')

    local f, err = open(pathname, 'w+')
    if not f then
        return false, err
    end

    -- add a comment
    self.macros[1] = format(concat({
        '/**',
        ' * this file is generated by lua-configh module at %s',
        ' */',
    }, '\n'), date())

    -- write macros
    local ok
    for _, line in ipairs(self.macros) do
        ok, err = f:write(line, '\n\n')
        if not ok then
            remove(pathname)
            f:close()
            return false, err
        end
    end

    ok, err = f:close()
    if not ok then
        remove(pathname)
        return false, err
    end

    self.macros = {}
    return true
end

--- set_feature set a feature macro definition
--- @param name string
--- @param value string?
function Configh:set_feature(name, value)
    self.exec:set_feature(name, value)
end

--- unset_feature unset a feature macro definition
--- @param name string
function Configh:unset_feature(name)
    self.exec:unset_feature(name)
end

local DECL_NAME_FORMAT = {
    header = '<%s>',
    ['function'] = "`%s'",
    type = "`%s'",
    member = "`%s'",
}

--- define_macro to add a macro definition to the macros list
--- @param self configh
--- @param decl string
--- | 'header'
--- | 'function'
--- | 'type'
--- | 'member'
--- @param name string
--- @param is_exists boolean
local function define_macro(self, decl, name, is_exists)
    -- check arguments
    assert(type(decl) == 'string' and DECL_NAME_FORMAT[decl],
           "decl must be 'header', 'function', 'type' or 'member'")
    assert(type(name) == 'string', 'name must be string')
    assert(type(is_exists) == 'boolean', 'is_exists must be boolean')

    local defname = gsub(name, '[^%w]', '_'):upper()
    local fmt = {
        format('/* Define to 1 if you have the ' .. DECL_NAME_FORMAT[decl] ..
                   ' %s. */', name, decl),
    }
    if is_exists then
        fmt[#fmt + 1] = format('#define HAVE_%s 1', defname)
    else
        fmt[#fmt + 1] = format('/* #undef HAVE_%s */', defname)
    end
    self.macros[#self.macros + 1] = concat(fmt, '\n')
end

--- check_header check whether the header file exists
--- @param header string
--- @return boolean ok true if the header file exists
--- @return string? err error for compile the generated source file
--- @return string? errerr error for failed to define macro
function Configh:check_header(header)
    assert(type(header) == 'string', 'header must be string')

    local ok, err = self.exec:check_header(header)
    if ok then
        define_macro(self, 'header', header, true)
        return true
    end
    define_macro(self, 'header', header, false)
    return false, err
end

--- check_func check whether the function exists
--- @param headers string|string[]
--- @param func string
--- @return boolean ok true if the function exists
--- @return string? err error for compile the generated source file
--- @return string? errerr error for failed to define macro
function Configh:check_func(headers, func)
    local ok, err = self.exec:check_func(headers, func)
    if ok then
        define_macro(self, 'function', func, true)
        return true
    end
    define_macro(self, 'function', func, false)
    return false, err
end

--- check_type check whether the type exists
--- @param headers string|string[]
--- @param ctype string
--- @return boolean ok true if the type exists
--- @return string? err error for compile the generated source file
--- @return string? errerr error for failed to define macro
function Configh:check_type(headers, ctype)
    local ok, err = self.exec:check_type(headers, ctype)
    if ok then
        define_macro(self, 'type', ctype, true)
        return true
    end
    define_macro(self, 'type', ctype, false)
    return false, err
end

Configh = require('metamodule').new(Configh)
return Configh
