--
-- Copyright (C) 2023 Masatoshi Fukunaga
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-- THE SOFTWARE.
--
local assert = assert
local concat = table.concat
local format = string.format
local gsub = string.gsub
local open = io.open
local date = os.date
local remove = os.remove
local vformat = require('print').format
local isfile = require('io.isfile')
local executor = require('configh.executor')

-- disable output buffering as default
local STDOUT = io.stdout
STDOUT:setvbuf('no')

--- @class configh
--- @field macros string[]
--- @field exec configh.executor
--- @field output boolean
--- @field outfile file*
local Configh = {}

--- new create a new configh object
--- @param cc string?
--- @return configh
function Configh:init(cc)
    self.macros = {}
    self.exec = executor(cc)
    self.output = false
    self.outfile = STDOUT

    return self
end

--- output_status output the execution status
--- @param enabled boolean
function Configh:output_status(enabled)
    assert(type(enabled) == 'boolean', 'enabled must be boolean')
    self.output = enabled
end

--- set_stdout set the output file for status messages
--- @param outfile file*?
function Configh:set_stdout(outfile)
    assert(outfile == nil or isfile(outfile), 'outfile must be file or nil')
    self.outfile = outfile or STDOUT
end

--- printf output the message to stdout
--- @param self configh
--- @param fmt string
--- @param ... any
local function printf(self, fmt, ...)
    if self.output then
        self.outfile:write(vformat(fmt, ...))
    end
end

--- flush flush the generated definitions to the file
--- @param pathname string
--- @return boolean ok
--- @return string? err
function Configh:flush(pathname)
    assert(type(pathname) == 'string', 'pathname must be string')

    -- add a header comment
    local lines = {
        [1] = format(concat({
            '/**',
            ' * this file is generated by lua-configh module at %s',
            ' */',
        }, '\n'), date()),
    }
    -- add features
    for _, line in ipairs(self.exec.features) do
        lines[#lines + 1] = line
        lines[#lines + 1] = ''
    end

    -- add macros
    for _, line in ipairs(self.macros) do
        lines[#lines + 1] = line
        lines[#lines + 1] = ''
    end
    self.macros = {}

    -- write to the file
    local ok
    local f, err = open(pathname, 'w+')
    if not f then
        return false, err
    end
    ok, err = f:write(concat(lines, '\n'))
    if ok then
        ok, err = f:close()
    end
    if not ok then
        remove(pathname)
    end
    return ok == true, err
end

--- set_feature set a feature macro definition
--- @param name string
--- @param value string?
function Configh:set_feature(name, value)
    self.exec:set_feature(name, value)
end

--- unset_feature unset a feature macro definition
--- @param name string
function Configh:unset_feature(name)
    self.exec:unset_feature(name)
end

--- add_cppflag add a cppflag
--- @param flag string
function Configh:add_cppflag(flag)
    self.exec:add_cppflag(flag)
end

--- remove_cppflag remove a cppflag
--- @param flag string
function Configh:remove_cppflag(flag)
    self.exec:remove_cppflag(flag)
end

local DECL_NAME_FORMAT = {
    header = '<%s>',
    ['function'] = "`%s'",
    type = "`%s'",
    decl = "`%s'",
    member = "`%s'",
}

--- define_macro to add a macro definition to the macros list
--- @param self configh
--- @param decl string
--- | 'header'
--- | 'function'
--- | 'type'
--- | 'decl'
--- | 'member'
--- @param name string
--- @param is_exists boolean
local function define_macro(self, decl, name, is_exists)
    -- check arguments
    assert(type(decl) == 'string' and DECL_NAME_FORMAT[decl],
           "decl must be 'header', 'function', 'type' or 'member'")
    assert(type(name) == 'string', 'name must be string')
    assert(type(is_exists) == 'boolean', 'is_exists must be boolean')

    local defname = gsub(name, '[^%w]', '_'):upper()
    local fmt = {
        format('/* Define to 1 if you have the ' .. DECL_NAME_FORMAT[decl] ..
                   ' %s. */', name, decl),
    }
    if is_exists then
        fmt[#fmt + 1] = format('#define HAVE_%s 1', defname)
    else
        fmt[#fmt + 1] = format('/* #undef HAVE_%s */', defname)
    end
    self.macros[#self.macros + 1] = concat(fmt, '\n')
end

local DECL_METHOD = {
    header = 'check_header',
    ['function'] = 'check_func',
    type = 'check_type',
    decl = 'check_decl',
    member = 'check_member',
}

--- do_check do the check
--- @param self configh
--- @param decl string
--- | 'header'
--- | 'function'
--- | 'type'
--- | 'decl'
--- | 'member'
--- @param params table<string, string>|table<'headers', string[]>
--- @return boolean ok
--- @return string? err
local function check(self, decl, params)

    assert(type(decl) == 'string' and DECL_METHOD[decl],
           "decl must be 'header', 'function', 'type' or 'member'")
    assert(type(params) == 'table', 'params must be table')
    assert(type(params.defname) == 'string', 'params.defname must be string')
    assert(type(params[decl]) == 'string' or type(params[decl]) == 'table',
           'params.' .. decl .. ' must be string or table')
    assert(params.display == nil or type(params.display) == 'string',
           'params.display must be string or nil')

    local method = DECL_METHOD[decl]

    printf(self, 'check %s: %s ... ', decl, params.display or params[decl])
    local ok, err
    if decl == 'header' then
        ok, err = self.exec[method](self.exec, params.header)
    elseif decl == 'member' then
        ok, err = self.exec[method](self.exec, params.headers, params.type,
                                    params.member)
    else
        ok, err = self.exec[method](self.exec, params.headers, params[decl])
    end

    if ok then
        printf(self, 'found\n')
    else
        printf(self, 'not found\n')
        printf(self, '  >  ' .. gsub(err, '\n', '\n  >  '), '\n')
    end

    define_macro(self, decl, params.defname, ok)
    return ok, err
end

--- check_header check whether the header file exists
--- @param header string
--- @return boolean ok true if the header file exists
--- @return string? err error for compile the generated source file
--- @return string? errerr error for failed to define macro
function Configh:check_header(header)
    assert(type(header) == 'string', 'header must be string')

    return check(self, 'header', {
        defname = header,
        header = header,
    })
end

--- check_func check whether the function exists
--- @param headers string|string[]
--- @param func string
--- @return boolean ok true if the function exists
--- @return string? err error for compile the generated source file
--- @return string? errerr error for failed to define macro
function Configh:check_func(headers, func)
    return check(self, 'function', {
        defname = func,
        headers = headers,
        ['function'] = func,
    })
end

--- check_type check whether the type exists
--- @param headers string|string[]
--- @param ctype string
--- @return boolean ok true if the type exists
--- @return string? err error for compile the generated source file
--- @return string? errerr error for failed to define macro
function Configh:check_type(headers, ctype)
    return check(self, 'type', {
        defname = ctype,
        headers = headers,
        type = ctype,
    })
end

--- check_decl check whether named symbol is defined as a macro or can be used as an r-value
--- @param headers string|string[]
--- @param name string
--- @return boolean ok true if the type exists
--- @return string? err error for compile the generated source file
--- @return string? errerr error for failed to define macro
function Configh:check_decl(headers, name)
    return check(self, 'decl', {
        defname = name,
        headers = headers,
        decl = name,
    })
end

--- check_member check whether the member field exists
--- @param headers string|string[]
--- @param ctype string
--- @param member string
--- @return boolean ok true if the type exists
--- @return string? err error for compile the generated source file
--- @return string? errerr error for failed to define macro
function Configh:check_member(headers, ctype, member)
    local defname = format('%s.%s', ctype, member)
    return check(self, 'member', {
        defname = defname,
        display = defname,
        headers = headers,
        type = ctype,
        member = member,
    })
end

Configh = require('metamodule').new(Configh)
return Configh
